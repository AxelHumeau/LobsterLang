-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/LobsterLang#readme</a>
@package LobsterLang
@version 0.1.0.0

module AST

-- | Abstract syntax tree for representing instructions
data Ast
Define :: String -> Ast -> Ast
Value :: Int -> Ast
Boolean :: Bool -> Ast
String :: String -> Ast
List :: [Ast] -> Ast
Symbol :: String -> Maybe [Ast] -> Ast
Call :: String -> [Ast] -> Ast
FunctionValue :: [String] -> Ast -> Maybe [Ast] -> Ast
Cond :: Ast -> Ast -> Maybe Ast -> Ast
instance GHC.Classes.Eq AST.Ast
instance GHC.Show.Show AST.Ast

module Compiler
compile :: [Ast] -> String -> Bool -> IO ()
astToInstructions :: Ast -> [Instruction]
compileInstructions :: [Instruction] -> Put
showInstructions :: [Instruction] -> IO ()
writeCompiledInstructionsToFile :: String -> Put -> IO ()
data Instruction
NoOp :: Instruction
PushI :: Int -> Instruction
PushB :: Bool -> Instruction
PushSym :: String -> Maybe [[Instruction]] -> Instruction
PushStr :: String -> Instruction
PushList :: Int -> [[Instruction]] -> Instruction
PushArg :: Int -> Instruction
PutArg :: Instruction
Jump :: Int -> Instruction
JumpIfFalse :: Int -> Instruction
Def :: String -> Int -> [Instruction] -> Instruction
Fnv :: Int -> [String] -> Int -> [Instruction] -> [Int] -> Maybe [[Instruction]] -> Instruction
Call :: Instruction
Ret :: Instruction
Cond :: [Instruction] -> Int -> [Instruction] -> Maybe [Instruction] -> Instruction
Add :: Instruction
Sub :: Instruction
Mul :: Instruction
Div :: Instruction
Mod :: Instruction

-- | ^ Comparison Operators
XorB :: Instruction
Eq :: Instruction
NotEq :: Instruction
Less :: Instruction
LessEq :: Instruction
Great :: Instruction
GreatEq :: Instruction
And :: Instruction
Or :: Instruction
Not :: Instruction
Then :: Instruction
ToStr :: Instruction
Neg :: Instruction
Apnd :: Instruction
RemAllOcc :: Instruction
Get :: Instruction
Len :: Instruction
data CompileConstants
Null :: CompileConstants
MagicNumber :: CompileConstants
instance GHC.Classes.Eq Compiler.CompileConstants
instance GHC.Show.Show Compiler.CompileConstants
instance GHC.Classes.Eq Compiler.Instruction
instance GHC.Show.Show Compiler.Instruction
instance GHC.Enum.Enum Compiler.Instruction
instance GHC.Enum.Enum Compiler.CompileConstants

module Parse
data Parser a
Parser :: (Position -> String -> Either String (a, String, Position)) -> Parser a
[runParser] :: Parser a -> Position -> String -> Either String (a, String, Position)

-- | Parse a character c Takes the character that need to be parsed Returns
--   a data Parser that contain the character and the rest of the string
parseChar :: Char -> Parser Char

-- | Parse with the first or the second parser Takes two parsers Returns
--   either the first parser or the second parser
parseOr :: Parser a -> Parser a -> Parser a

-- | Parse with the first and the second parser Takes two parsers Returns
--   either the first parser then use result for the second parser
parseAnd :: Parser a -> Parser b -> Parser (a, b)

-- | Parse with function after the two parsers Takes two parsers and a fh
--   (x _ -&gt; x) unction Returns the result of the function with the
--   result of the parseAnd
parseAndWith :: (a -> b -> c) -> Parser a -> Parser b -> Parser c

-- | Parse with a parser Takes a parser Returns the application of the
--   parser (if nothing, returns an empty list)
parseMany :: Parser a -> Parser [a]

-- | Parse with a parser Takes a parser Returns the application of the
--   parser at least one time or Returns Nothing
parseSome :: Parser a -> Parser [a]

-- | Return a data Parser that parse a UInt
parseUInt :: Parser Int

-- | Return a data Parser that parse a Int
parseInt :: Parser Int

-- | Parse any character from a String Return a Parser that parse every
--   character from a String
parseAnyChar :: String -> Parser Char

-- | Parse a list of element Return a Parser of list <tt>element</tt> that
--   start with a '(' and end with a ')'
parseList :: Parser a -> String -> String -> Parser [a]

-- | Return a data Parser that parse a String
parseString :: Parser String

-- | Return a data Parser that parse a <a>-</a> or <a>+</a>
parseSign :: Parser Char

-- | Return a data Parser that parse a digit
parseDigit :: Parser Char

-- | Return a Parser that parse a Bool (#f or #t)
parseBool :: Parser Ast

-- | Return a Parser that parse a SExpr
parseAst :: Parser Ast

-- | Parse with a parser and, if possible with a space Return a Parser that
--   parse element with the given parser and, if possible with multiple
--   space
parseElem :: Parser a -> Parser a

-- | Return a data Parser that parse a Int as a Value
parseValue :: Parser Ast
parseLobster :: Parser [Ast]

-- | Parse a specific String
parseAnyString :: String -> Parser String
parseCmpString :: String -> Parser String
parseDefineValue :: Parser Ast
parseProduct :: Parser Ast
parseSum :: Parser Ast
parseExpr :: Parser Ast

-- | Return a PArser that parse a True (in lisp -&gt; #t)
parseTrue :: Parser Bool

-- | Return a PArser that parse a True (in lisp -&gt; #f)
parseFalse :: Parser Bool

-- | Return a data Parser that parse a String as a Symbol
parseAstString :: Parser Ast
parseWhiteSpace :: Parser [Char]
errorParsing :: (Int, Int) -> String
parseDefineFn :: Parser Ast
parseLambda :: Parser Ast
parseCond :: Parser Ast
parseFunctionValue :: Parser Ast
parseBracket :: Parser Ast
parseComment :: Parser Char
instance GHC.Classes.Eq Parse.Token
instance GHC.Show.Show Parse.Token
instance GHC.Base.Functor Parse.Parser
instance GHC.Base.Applicative Parse.Parser
instance GHC.Base.Alternative Parse.Parser
instance GHC.Base.Monad Parse.Parser

module SExpr

-- | S-Expression
data SExpr
Value :: Int -> SExpr
Symbol :: String -> SExpr
List :: [SExpr] -> SExpr

-- | Get the <a>Symbol</a> contained in this expression
getSymbol :: SExpr -> Maybe String

-- | Get the <a>Integer</a> contained in this expression
getInteger :: SExpr -> Maybe Int

-- | Get the <a>List</a> contained in this expression
getList :: SExpr -> Maybe [SExpr]

-- | Return a string representation of the S-Expression
printTree :: SExpr -> Maybe String
instance GHC.Classes.Eq SExpr.SExpr
instance GHC.Show.Show SExpr.SExpr

module Stack

-- | Return the top of the stack
top :: [a] -> Maybe a

-- | Push a value onto the stack, return the new stack
push :: [a] -> a -> [a]

-- | Remove the top of the stack, return a tuple containing the old top and
--   the new stack
pop :: [a] -> (Maybe a, [a])

-- | Return the first element of the stack validating the function given as
--   parameter
seek :: (a -> Bool) -> [a] -> Maybe a

-- | Return the size of the stack
size :: [a] -> Int

-- | Clear the stack by return an empty stack
clear :: [a] -> [a]

module Scope

-- | Structure representing a member in a scope. Can be a <a>ScopeBegin</a>
--   to mark the beginning of a scope or a <a>Variable</a> containing its
--   name as a <a>Ast</a> and its value as an <a>Ast</a>
data ScopeMb
ScopeBegin :: Int -> ScopeMb
Variable :: String -> Ast -> Int -> ScopeMb

-- | Begin a new scope by adding a <a>ScopeBegin</a> to the stack.
beginScope :: [ScopeMb] -> [ScopeMb]

-- | Clear the current scope
clearScope :: [ScopeMb] -> [ScopeMb]

-- | Add a Variable to the stack with its name as a <a>Ast</a> and its
--   value by an <a>Ast</a>
addVarToScope :: [ScopeMb] -> String -> Ast -> [ScopeMb]

-- | Get the value contained in the variable given by name as a <a>Ast</a>,
--   return <a>Nothing</a> if the variable don't exist or <a>Just</a> its
--   value
getVarInScope :: [ScopeMb] -> String -> Maybe Ast

-- | Add multiple variables to the stack with their names as a <a>Ast</a>
--   and their values as an <a>Ast</a>
addVarsToScope :: [ScopeMb] -> [String] -> [Ast] -> [ScopeMb]

-- | Update the given variable, don't do anything if it doesn't exist
updateVar :: [ScopeMb] -> String -> Ast -> [ScopeMb]
instance GHC.Show.Show Scope.ScopeMb
instance GHC.Classes.Eq Scope.ScopeMb

module AstEval

-- | Evaluate a <a>Ast</a>. Takes a stack representing variables and the
--   Ast to evaluate. Returns a tuple containing either the resulting Ast
--   (can be <a>Nothing</a> for no evaluation is possible) or a <a>Ast</a>
--   containing the error message in case of error and the stack after
--   evaluation.
evalAst :: [ScopeMb] -> Ast -> (Either String (Maybe Ast), [ScopeMb])

-- | Evaluate the <a>Ast</a> for a given binary value operator such as
--   <a>+</a>, <a>-</a>, or <a>*</a>. Takes a function that takes two
--   <a>Int</a> and return one <a>Int</a>, the stack as a '[ScopeMb]', and
--   the <a>Ast</a> to evaluate. Return a tuple containing the new stack
--   post evaluation, and the application of the function onto the values
--   inside the given <a>Ast</a> or a <a>Ast</a> containing the error
--   message in case of error
evalBiValOp :: (Int -> Int -> Int) -> [ScopeMb] -> Ast -> (Either String (Maybe Ast), [ScopeMb])

-- | Evaluate the <a>Ast</a> for a given binary boolean operator such as
--   <a>&amp;&amp;</a> or <a>||</a>. Takes a function that takes two
--   <a>Bool</a> and return one <a>Bool</a>, the stack as a '[ScopeMb]',
--   and the <a>Ast</a> to evaluate. Return a tuple containing the new
--   stack post evaluation, and the application of the function onto the
--   booleans inside the given <a>Ast</a> or a <a>Ast</a> containing the
--   error message in case of error
evalBiBoolOp :: (Bool -> Bool -> Bool) -> [ScopeMb] -> Ast -> (Either String (Maybe Ast), [ScopeMb])

-- | Evaluate the <a>Ast</a> for a given binary comparison operator such as
--   <a>==</a>, <a>&gt;</a>, or <a>&lt;=</a>. Takes a function that takes
--   two <a>Int</a> and return one <a>Bool</a>, the stack as a '[ScopeMb]',
--   and the <a>Ast</a> to evaluate. Return a tuple containing the new
--   stack post evaluation, and the application of the function onto the
--   values inside the given <a>Ast</a> or a <a>Ast</a> containing the
--   error message in case of error
evalBiCompValOp :: (Int -> Int -> Bool) -> [ScopeMb] -> Ast -> (Either String (Maybe Ast), [ScopeMb])

module AstOptimizer

-- | Optimize a list of <a>Ast</a> and check for invalid operation:
--   optimization is taking place when operation have the same result no
--   matter what for exemple `3 + 3`, when a forbidden operation is taking
--   place, the optimization results in an <a>AstError</a>, when the
--   optimization was a success it results in an <a>AstOptimised</a>. Takes
--   the stack (`[ScopeMb]`), a list of <a>Ast</a>, a boolean to indicate
--   whether the optimization take place insinde a function and returns the
--   list of <a>Either</a> <a>AstError</a> or <a>AstOptimised</a>
optimizeAst :: [ScopeMb] -> [Ast] -> Bool -> [Either AstError AstOptimised]

-- | Get the <a>Ast</a> contained in a <a>AstOptimised</a>
fromOpti :: AstOptimised -> Ast
data AstError
Error :: String -> Ast -> AstError
data AstOptimised

-- | The <a>Ast</a> after optimization
Result :: Ast -> AstOptimised

-- | When the optimization throw a warning contains the warining message
--   and the <a>Ast</a> post optimization that caused it
Warning :: String -> Ast -> AstOptimised
instance GHC.Show.Show AstOptimizer.AstError
instance GHC.Classes.Eq AstOptimizer.AstError
instance GHC.Show.Show AstOptimizer.AstOptimised
instance GHC.Classes.Eq AstOptimizer.AstOptimised

module Vm
data Operator
Add :: Operator
Sub :: Operator
Mul :: Operator
Div :: Operator
Mod :: Operator
Eq :: Operator
Less :: Operator
LessEq :: Operator
Great :: Operator
GreatEq :: Operator
And :: Operator
Or :: Operator
Xorb :: Operator
Not :: Operator
ToString :: Operator
Get :: Operator
Append :: Operator
RmOcc :: Operator
Len :: Operator
data Value
IntVal :: Int -> Value
BoolVal :: Bool -> Value
CharVal :: Char -> Value
StringVal :: String -> Value
ListVal :: [Value] -> Value
Op :: Operator -> Value
Function :: Func -> Int -> Value
data Instruction
Push :: Value -> Instruction
PushArg :: Int -> Instruction
PushEnv :: String -> Instruction
PutArg :: Instruction
Call :: Instruction
JumpIfFalse :: Int -> Instruction
JumpIfTrue :: Int -> Instruction
Jump :: Int -> Instruction
Define :: String -> Instruction
PushList :: Int -> Instruction
Ret :: Instruction
type Stack = [Value]
type Inst = [Instruction]
type Arg = [Value]
type Func = [Instruction]
type Env = [(String, Value, Int)]
makeOperation :: Operator -> Stack -> Either String Stack
exec :: Int -> Env -> Arg -> Inst -> Stack -> (Either String Value, Env)
instance GHC.Classes.Ord Vm.Value
instance GHC.Classes.Eq Vm.Value
instance GHC.Show.Show Vm.Value
instance GHC.Num.Num Vm.Value
instance GHC.Real.Fractional Vm.Value
instance GHC.Show.Show Vm.Instruction
instance GHC.Classes.Ord Vm.Instruction
instance GHC.Classes.Eq Vm.Instruction
instance GHC.Classes.Ord Vm.Operator
instance GHC.Show.Show Vm.Operator
instance GHC.Classes.Eq Vm.Operator

module CompiletoVm
convert :: ByteString -> Inst -> IO Inst
makeConvert :: String -> IO Inst
getString :: Int -> ByteString -> String -> (String, ByteString)
getList :: Int -> ByteString -> [Instruction] -> ([Instruction], ByteString)
getDefinedValue :: Int -> ByteString -> [Instruction] -> ([Instruction], ByteString)
getFnv :: Int -> ByteString -> [Instruction] -> ([Instruction], ByteString)
getArg :: Int -> ByteString -> [Instruction] -> ([Instruction], ByteString)
